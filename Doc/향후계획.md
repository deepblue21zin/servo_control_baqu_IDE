# 자율주행 조향 시스템 - 향후 계획

## 1. 현재 코드 vs 자율주행 시스템

### 현재 코드 (오픈 루프 데모)

```
┌─────────────┐
│  하드코딩    │     pulse_forward(5000)
│  명령       │ ──────────────────────────→  모터 회전
│  (main.c)   │     pulse_reverse(5000)
└─────────────┘

      ❌ 센서 입력 없음
      ❌ 피드백 없음
      ❌ 상황 판단 없음
```

### 자율주행 시스템 구조

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   센서 입력   │ → │   판단/결정   │ → │   제어 명령   │ → │   모터 출력   │
└──────────────┘    └──────────────┘    └──────────────┘    └──────────────┘
 - 카메라          - 경로 계획         - 목표 각도 설정    - PID 제어
 - LiDAR           - 장애물 회피       - 속도 설정         - PWM 출력
 - 초음파          - 차선 유지
 - GPS
```

---

## 2. 시스템 계층 구조

### 현재 구현된 것

| 계층 | 파일 | 상태 |
|------|------|------|
| **하드웨어 계층** | encoder_reader.c | ✅ 완료 |
| | pulse_control.c | ✅ 완료 |
| | relay_control.c | ✅ 완료 |
| **제어 계층** | position_control.c | ✅ 완료 (미사용) |

### 추가해야 할 것

| 계층 | 기능 | 상태 |
|------|------|------|
| **센서 계층** | 상위 시스템에서 명령 수신 (UART/CAN/Ethernet) | ❌ 미구현 |
| **판단 계층** | 수신된 명령을 목표 각도로 변환 | ❌ 미구현 |

---

## 3. 실제 자율주행에서의 역할 분담

```
┌─────────────────────────────────────────────────────────────────┐
│                    상위 제어기 (메인 컴퓨터)                       │
│         (Jetson, Raspberry Pi, 산업용 PC 등)                     │
├─────────────────────────────────────────────────────────────────┤
│  1. 센서 데이터 수집 (카메라, LiDAR, GPS)                         │
│  2. 환경 인식 (장애물, 차선, 표지판)                               │
│  3. 경로 계획 (어디로 갈지)                                       │
│  4. 조향 각도 계산 → "왼쪽 30도로 틀어라"                         │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                    UART / CAN / Ethernet
                    "TARGET:30.0" 명령 전송
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                    STM32 (지금 만든 것)                          │
├─────────────────────────────────────────────────────────────────┤
│  1. 명령 수신: "30도로 가라"                                      │
│  2. PID 제어: 현재 위치 → 30도까지 이동                           │
│  3. 펄스 출력: 서보드라이버 구동                                   │
│  4. 피드백: "현재 29.5도" 응답                                    │
└─────────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│              서보드라이버 → 서보모터 → 조향 장치                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 다음 단계: 통신 프로토콜 추가

### main.c 수정 예시

```c
// 상위 시스템에서 명령 수신용 버퍼
char rx_buffer[32];
float target_angle = 0.0f;

while (1) {
    // 1. 상위 시스템에서 명령 수신 (UART)
    if (HAL_UART_Receive(&huart1, rx_buffer, 32, 10) == HAL_OK) {
        // 예: "TARGET:30.5" 파싱
        if (strncmp(rx_buffer, "TARGET:", 7) == 0) {
            target_angle = atof(&rx_buffer[7]);
            PositionControl_SetTarget(target_angle);
        }
    }

    // 2. PID 제어 실행 (1ms마다)
    PositionControl_Update();

    // 3. 현재 상태 응답
    float current = PositionControl_GetCurrentAngle();
    printf("POS:%.2f\n", current);
}
```

---

## 5. 통신 방식 선택

| 방식 | 장점 | 단점 | 용도 |
|------|------|------|------|
| **UART** | 간단, 디버깅 쉬움 | 느림, 1:1 통신 | 테스트, 간단한 시스템 |
| **CAN** | 노이즈 강함, 멀티노드 | 구현 복잡 | 자동차, 산업용 |
| **Ethernet** | 고속, 대용량 | 복잡 | 고급 자율주행 |

---

## 6. 개발 로드맵

### Phase 1: 기본 동작 확인 ✅ 완료
- [x] 서보모터 구동 (pulse_forward/reverse)
- [x] 엔코더 위치 읽기
- [x] PID 제어 알고리즘
- [x] 릴레이 제어
- [x] 안전 기능 (비상정지, 각도 제한)

### Phase 2: 통신 구현 ❌ 예정
- [ ] UART 명령 수신부 구현
- [ ] 명령 파서 (문자열 → 숫자 변환)
- [ ] 메인 루프에서 PID 제어 호출
- [ ] 상태 피드백 (현재 위치 전송)

### Phase 3: 상위 시스템 연동 ❌ 예정
- [ ] 상위 컴퓨터와 통신 테스트
- [ ] 프로토콜 정의 (명령/응답 포맷)
- [ ] 에러 처리 및 타임아웃

### Phase 4: 고급 기능 ❌ 예정
- [ ] CAN 통신 구현 (자동차 표준)
- [ ] 속도 제어 추가
- [ ] 진단 기능 (알람, 상태 모니터링)

---

## 7. 통신 프로토콜 설계 (안)

### 명령 포맷 (상위 → STM32)

| 명령 | 형식 | 설명 |
|------|------|------|
| 목표 설정 | `TARGET:30.5\n` | 목표 각도 30.5도 |
| 서보 ON | `SVON:1\n` | 서보 활성화 |
| 서보 OFF | `SVON:0\n` | 서보 비활성화 |
| 비상정지 | `EMG:1\n` | 비상정지 |
| 상태 요청 | `STATUS?\n` | 현재 상태 요청 |

### 응답 포맷 (STM32 → 상위)

| 응답 | 형식 | 설명 |
|------|------|------|
| 현재 위치 | `POS:29.5\n` | 현재 각도 29.5도 |
| 상태 | `STATUS:OK,POS:29.5,TARGET:30.0,STABLE:1\n` | 전체 상태 |
| 에러 | `ERROR:OVER_LIMIT\n` | 에러 발생 |
| 확인 | `ACK\n` | 명령 수신 확인 |

---

## 8. 결론

**STM32의 역할:**
- "조향 각도를 받아서 정확히 그 각도로 모터를 움직이는" 하위 제어기

**상위 컴퓨터의 역할:**
- 센서 기반 환경 인식
- 장애물 회피 판단
- 경로 계획
- 조향 각도 계산 → STM32로 명령 전송

**다음 할 일:**
1. UART 통신 수신부 구현
2. 명령 파서 구현
3. PID 제어를 메인 루프에 통합
4. 상위 시스템과 연동 테스트
